%%------------------------------------------------------
% 
%% UNIVERSIDADE FEDERAL DE SANTA CATARINA - UFSC
%
%% Prof.: Wyllian B. da Silva
%%
%% Template: estilo IEEEtran [paper com duas colunas]
%% Adaptado de: https://ieeeauthorcenter.ieee.org/create-your-ieee-article/use-authoring-tools-and-ieee-article-templates/ieee-article-templates/templates-for-transactions/
%               https://ctan.org/tex-archive/macros/latex/contrib/IEEEtran?lang=en

%% Instruções: http://mirrors.ctan.org/macros/latex/contrib/IEEEtran/IEEEtran_HOWTO.pdf
%%
%% Recomendações:
%% Utilize o Editor Kile (SO Linux)
%% Certifique-se de que a codificação de caracteres utilizada é a UTF-8
%%
%% ARQUIVO MODIFICADO PARA O PROJETO GOMOKU
%%
%%------------------------------------------------------

\documentclass[journal]{IEEEtran}


%%------------------------------------------------------
%% Packages
%%------------------------------------------------------
\usepackage[T1]{fontenc}       %% Codificação de caracteres
\usepackage[utf8]{inputenc}    %% Codificação de caracteres (conversão automática dos acentos)
\usepackage[dvips]{graphicx}   %% para a macro includegraphics 
\usepackage[english,brazil]{babel} %% PT_BR e EN (o último define a prioridade no arquivo)
\usepackage{pgf}               %% macro para criar gráficos
\usepackage{epsfig}            %% or use the epsfig package if you prefer to use the old commands
\usepackage{graphics}          %% use the graphics package for simple commands
\usepackage{graphicx}          %% or 
\usepackage{epstopdf}          %% enable EPS (convert to PDF)
\usepackage{float}             %% float environment
\usepackage{eqparbox}          %% to define a group of boxes 
\usepackage{hyphenat}          %% prevent hyphenation
\usepackage{hyperref}          %% enalbe one-click link

\usepackage{listings}          %% Para blocos de código
\usepackage{xcolor}            %% Para cores no código

\usepackage[numbers,sort&compress,square]{natbib} %% e.g., [2-5]

%% --- CORES DO CÓDIGO (Sintaxe Colorida) ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

%% Definitions

\hyphenation{op-tical net-works semi-conduc-tor}

\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


\makeatletter

\newcommand{\prenome}{\afterassignment\prenome@aux\count0=}
\newcommand{\prenome@aux}{\csname prenome\the\count0\endcsname}

\newcommand{\nomedomeio}{\afterassignment\nomedomeio@aux\count0=}
\newcommand{\nomedomeio@aux}{\csname nomedomeio\the\count0\endcsname}

\newcommand{\sobrenome}{\afterassignment\sobrenome@aux\count0=}
\newcommand{\sobrenome@aux}{\csname sobrenome\the\count0\endcsname}
\makeatother

%% --- CORES DOS LINKS DO TEXTO (Removido Vermelho/Verde) ---
\hypersetup{
  colorlinks=true,
  urlcolor=blue,      % Links externos em azul
  linkcolor=black,    % Links internos (Figuras/Seções) em PRETO
  citecolor=black,    % Citações [1] em PRETO
  filecolor=black,
  pdfborder={0 0 0},
}

%%----------------- Título
\title{Gomoku - Projeto Web}

\newcommand{\emailautor}               {aleccoelho50@gmail.com}
\newcommand{\emailautordois}           {luanrodrigosilvacosta@gmail.com}

\newcommand{\siglaRevista}             {INE5646}
\newcommand{\Revista}                  {Universidade Federal de Santa Catarina (UFSC)}


\newcommand{\prenomePrincipal}         {Alec}
\newcommand{\nomedomeioPrincipal}      {Oliveira}
\newcommand{\sobrenomePrincipal}       {Coelho}

\expandafter\newcommand\csname prenome2\endcsname     {Luan}
\expandafter\newcommand\csname nomedomeio2\endcsname  {Rodrigo da Silva}
\expandafter\newcommand\csname sobrenome2\endcsname   {Costa}

\author{\IEEEauthorblockN{\prenomePrincipal~\nomedomeioPrincipal~\sobrenomePrincipal\IEEEauthorrefmark{1}, 
\prenome2~\nomedomeio2~\sobrenome2\IEEEauthorrefmark{1}}

\IEEEauthorblockA{\IEEEauthorrefmark{1}Departamento de Informática e Estatística (INE), 
Universidade Federal de Santa Catarina (UFSC), Florianópolis, SC, Brasil}

\thanks{\Revista~(\siglaRevista). Correspond\^encia ao autor: \prenomePrincipal~\sobrenomePrincipal~(email: \emailautor) e \prenome2~\sobrenome2~(email: \emailautordois).}}


%%------------------------------------------------------
%% Abstract
\IEEEtitleabstractindextext{

  {\selectlanguage{brazil}
    \begin{abstract}
    Este artigo descreve a implementação de um projeto web completo para a disciplina INE5646 - Programação para Web da UFSC. O projeto consiste em um jogo Gomoku (ou Five in a Row), desenvolvido com uma arquitetura de aplicação web. O \textit{backend} foi implementado em Python utilizando o \textit{framework} FastAPI. O \textit{frontend} foi desenvolvido em React com TypeScript. O armazenamento de dados, incluindo perfis de usuário, estados de jogo e gravações de partidas, é gerenciado pelo banco de dados NoSQL MongoDB, um requisito obrigatório do projeto. A comunicação em tempo real entre jogadores, como o \textit{chat} e a sincronização de movimentos, é realizada via WebSockets. Funcionalidades como gravação de partidas usando FFMPEG também foram implementadas a fim de cumprir com todos os requisitos do projeto.
    \end{abstract}
    %%----------------- Keywords
    \renewcommand\IEEEkeywordsname{Palavras-chave}
    \begin{IEEEkeywords}
    Gomoku, Programação Web, FastAPI, React, TypeScript, MongoDB, WebSocket, FFMPEG, Arquitetura MVC.
    \end{IEEEkeywords}
  }
}


\begin{document}



%%------------------------------------------------------
%% Inserção de informações
\maketitle
\IEEEdisplaynontitleabstractindextext
\IEEEpeerreviewmaketitle


%%------------------------------------------------------
%% Section
\section{Introdução}

\IEEEPARstart{O}{} projeto web desenvolvido para a disciplina INE5646 - Programação para Web da UFSC teve como objetivo a criação de uma aplicação web implementando o jogo de estratégia Gomoku, também conhecido como "Five In a Row".

\subsection{Motivação}
A principal motivação do projeto foi aplicar os conceitos e técnicas abordados na disciplina em um cenário prático. A escolha de um jogo \textit{multiplayer} estratégico permite grande liberdade na escolha e aplicação das tecnologias de \textit{backend} e \textit{frontend} a serem utilizadas. O desafio consistia em construir um sistema robusto, e que integrasse as diversas ferramentas exigidas pelo plano de ensino, gravação de partidas e o protocolo HTTPS.

\subsection{Problema}
O problema central do projeto foi desenvolver uma aplicação \textit{full-stack} que suportasse múltiplos modos de jogo (PvP online, PvP local e PvE contra IA), autenticação de usuários, comunicação em tempo real e funcionalidades de mídia, como a gravação de partidas. A solução deveria seguir o padrão de projeto MVC (Model-View-Controller), ser responsiva (desktop e mobile) e atender a diversos requisitos de segurança e infraestrutura, incluindo o \textit{deploy} obrigatório em um servidor VPS-UFSC.

%\subsection{Trabalhos Relacionados}
%TODO

\subsection{Contribuição do Trabalho}
A principal contribuição deste trabalho é a integração bem-sucedida de todas as tecnologias apresentadas durante o semestre letivo. Demonstra-se uma arquitetura desacoplada onde o \textit{backend} atua como uma API RESTful e um servidor WebSocket, o \textit{frontend} (React) utiliza esses serviços e os traduz de forma visual, e o MongoDB gerencia a persistência de dados.

\subsection{Organização do Trabalho}
Este artigo está organizado da seguinte forma: A Seção \ref{sec:fundamentacao} apresenta a fundamentação teórica sobre as principais tecnologias utilizadas. A Seção \ref{sec:metodologia} detalha os materiais e métodos, incluindo a arquitetura do sistema e o roteiro de instalação. A Seção \ref{sec:resultados} discute os resultados obtidos, a estrutura do projeto, os problemas encontrados e as soluções de segurança. Finalmente, a Seção \ref{sec:conclusao} apresenta as conclusões do trabalho.


%%------------------------------------------------------
%% Section
\section{Fundamentação Teórica}
\label{sec:fundamentacao}

Esta seção aborda os conceitos teóricos das principais tecnologias que formam a \textit{stack} do projeto Gomoku.

\subsection{FastAPI}
FastAPI é um \textit{framework} web Python, baseado em Starlette (para a parte assíncrona ASGI) e Pydantic (para validação de dados) \cite{doc:fastapi}. Sua arquitetura permite o desenvolvimento de APIs RESTful e o gerenciamento de conexões WebSocket, sendo ideal para aplicações que exigem baixa latência e I/O intensivo, como o \textit{backend} deste projeto.

\subsection{React e TypeScript}
React é uma biblioteca JavaScript para a construção de interfaces de usuário (UI) baseada em componentes \cite{doc:react}. Ele utiliza um \textit{Virtual DOM} para otimizar as atualizações da UI, resultando em uma experiência de usuário fluida. TypeScript é um \textit{superset} do JavaScript que adiciona tipagem estática \cite{doc:typescript}, utilizado no projeto para garantir a manutenibilidade, robustez e escalabilidade do código do \textit{frontend}.

\subsection{MongoDB}
MongoDB é um banco de dados NoSQL orientado a documentos, que armazena dados em estruturas BSON (\textit{Binary} JSON) \cite{doc:mongodb}. Foi o banco de dados obrigatório para o projeto e é utilizado para persistir dados de usuários, jogos e placares. O projeto utiliza Volumes Docker para armazenar arquivos grandes, como as gravações de vídeo das partidas, visando performance de I/O.

\subsection{WebSocket}
O protocolo WebSocket fornece um canal de comunicação bidirecional e \textit{full-duplex} sobre uma única conexão TCP. Diferente do ciclo de requisição-resposta do HTTP, o WebSocket mantém uma conexão persistente, permitindo que o servidor envie dados ao cliente proativamente. Esta tecnologia é a base para as funcionalidades em tempo real do projeto, como o chat, o \textit{lobby} e a sincronização dos movimentos no tabuleiro.

\subsection{FFMPEG}
FFMPEG é uma suíte de \textit{software} livre para manipulação, gravação, conversão e \textit{streaming} de áudio e vídeo \cite{doc:ffmpeg}. Conforme os requisitos do projeto, o FFMPEG é utilizado no \textit{backend} para processar e gravar as partidas no formato WebM, que são subsequentemente armazenadas no sistema de arquivos do servidor.

%%------------------------------------------------------
%% Section
\section{Materiais e Métodos}
\label{sec:metodologia}

Esta seção descreve a arquitetura do projeto, as ferramentas utilizadas e o processo de configuração e instalação para replicação do ambiente.

\subsection{Arquitetura da Aplicação}
A aplicação segue um padrão de projeto próximo ao MVC (Model-View-Controller), desacoplado em dois serviços principais:

\begin{itemize}
    \item \textbf{Backend (API):} Implementado em FastAPI, serve como o \textit{Controller} e o \textit{Model}. Ele expõe uma API RESTful para gerenciamento de usuários e jogos, e um \textit{endpoint} WebSocket para comunicação em tempo real (chat, lobby, jogadas). Ele se comunica com o banco de dados MongoDB (usando o \textit{driver} assíncrono Motor) para persistir os dados.
    \item \textbf{Frontend (View):} Implementado em React com TypeScript, é a camada de visualização. Consome a API RESTful do \textit{backend} para operações de dados e se conecta ao WebSocket para atualizações em tempo real. O estado da aplicação é gerenciado localmente nos componentes e através de Contexts do React.
    \item \textbf{Banco de Dados:} O MongoDB (hospedado no MongoDB Atlas em produção) atua como a camada de persistência.
    \item \textbf{Infraestrutura:} A aplicação é orquestrada utilizando Docker e Docker Compose, facilitando os ambientes de desenvolvimento e produção.
\end{itemize}

\subsection{Tecnologias, Frameworks e APIs}
A Tabela \ref{tab:backend-stack} e a Tabela \ref{tab:frontend-stack} resumem as principais tecnologias usadas no \textit{backend} e \textit{frontend}, respectivamente.

\begin{table}[!htbp]
\renewcommand{\arraystretch}{1.3}
\caption{Stack do Backend}
\label{tab:backend-stack}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Tecnologia} & \textbf{Descrição} \\
\hline
FastAPI & Framework web assíncrono (ASGI) \\
Motor & Driver MongoDB assíncrono \\
Uvicorn & Servidor ASGI \\
WebSockets & Comunicação em tempo real \\
python-jose & Autenticação JWT \\
ffmpeg-python & Wrapper para gravação de vídeo \\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\renewcommand{\arraystretch}{1.3}
\caption{Stack do Frontend}
\label{tab:frontend-stack}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Tecnologia} & \textbf{Descrição} \\
\hline
React & Biblioteca de UI \\
TypeScript & Tipagem estática para JavaScript \\
Axios & Cliente HTTP (REST) \\
Native WebSocket & API nativa do navegador \\
React Router & Roteamento de páginas \\
\hline
\end{tabular}
\end{table}

\subsection{Softwares e Roteiro de Instalação}
O projeto é desenhado para ser executado com Docker e Docker Compose, simplificando a configuração do ambiente.

\subsubsection{Pré-requisitos}
\begin{itemize}
    \item Docker
    \item Docker Compose
    \item Git
\end{itemize}

\subsubsection{Roteiro de Instalação (Produção)}
O processo de \textit{deploy} em modo de produção é feito com o Docker Compose, que constrói e orquestra os contêineres do \textit{backend}, \textit{frontend} (servido via Nginx) e MongoDB.

\begin{lstlisting}[language=Bash, caption={Comandos para execução em modo produção}]
# Clone o repositorio
git clone https://github.com/Coelho50/Gomoku.git
cd Gomoku

# Execute em modo producao (com Nginx)
docker-compose -f docker-compose.yml up -d --profile production
\end{lstlisting}

\subsubsection{Roteiro de Instalação (Desenvolvimento)}
O modo de desenvolvimento utiliza o Docker Compose para subir os serviços com \textit{hot-reloading} no \textit{backend} (Uvicorn) e \textit{frontend} (React Scripts), além de expor um painel de administração do MongoDB (Mongo Express).

\begin{lstlisting}[language=Bash, caption={Comandos para execução em modo desenvolvimento}]
# Execute com MongoDB Admin Interface
docker-compose --profile debug up

# Portas em Modo Debug:
# Frontend: http://localhost:9001
# Backend API: http://localhost:9000
# MongoDB Admin: http://localhost:8081
\end{lstlisting}

\subsection{Links do Projeto}
\begin{itemize}
    \item \textbf{Repositório GitHub:} \href{https://github.com/piloto-life/Gomoku}{https://github.com/piloto-life/Gomoku}
    \item \textbf{Link da Aplicação (VPS-UFSC):} \href{https://web.luan.costa.vms.ufsc.br/}{https://web.luan.costa.vms.ufsc.br/}
\end{itemize}

%%------------------------------------------------------
%% Section
\section{Resultados}
\label{sec:resultados}

Esta seção apresenta os resultados da implementação, a estrutura final do projeto, os problemas encontrados durante o desenvolvimento e as soluções de segurança aplicadas.

\subsection{Estrutura do Projeto (MVC)}
O \textit{backend} foi estruturado seguindo o padrão MVC, adaptado para o FastAPI:
\begin{itemize}
    \item \textbf{Models:} Definidos em `backend/models/`, usando Pydantic para validação de dados de API e classes para os modelos do MongoDB.
    \item \textbf{Views (Templates):} O \textit{backend} é \textit{headless} (sem \textit{view}), sendo o React a camada de visualização desacoplada.
    \item \textbf{Controllers (Rotas):} Definidos em `backend/routers/`. Cada arquivo (e.g. `auth.py`, `games.py`, `websocket.py`) agrupa a lógica de negócios para um conjunto de \textit{endpoints}, recebendo requisições, interagindo com os serviços e retornando respostas JSON.
    \item \textbf{Services:} A lógica de negócios complexa (ex: cálculo de ELO, gravação FFMPEG) foi abstraída em \verb|backend/services/|, como \verb|ranking_service.py| e \verb|ffmpeg_service.py|.
    \item \textbf{Game Manager:} Singleton em memória (\texttt{game\_manager.py}) que gerencia a fila de \textit{matchmaking} e estados transitórios antes da persistência no banco.
\end{itemize}

A Figura \ref{fig:estrutura-backend} ilustra a árvore de diretórios principal do \textit{backend}.

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.5\columnwidth]{figs/backend_tree.png}
\caption{Estrutura de diretórios do serviço de backend.}
\label{fig:estrutura-backend}
\end{figure}

\subsection{Funcionalidades Implementadas}
O projeto implementou com sucesso todas as funcionalidades requisitadas:
\begin{itemize}
    \item \textbf{Gravação com FFMPEG:} O \verb|`ffmpeg_service.py`| gerencia a gravação de partidas, com APIs para iniciar, parar e listar gravações. Os vídeos são armazenados no sistema de arquivos e podem ser acessados via \textit{streaming} por uma URL.
    \item \textbf{Sistema de Ranking ELO:} O \verb|`ranking_service.py`| calcula o ELO dos jogadores após cada partida online (Fator \verb|K=32|), armazena estatísticas e fornece \textit{endpoints} para um \textit{leaderboard} global.
    \item \textbf{Administração CRUD:} O `routers/admin.py` implementa um conjunto completo de rotas protegidas para gerenciamento de usuários, jogos e configurações do sistema.
    \item \textbf{Design Responsivo:} Conforme detalhado em \verb|`DESIGN_IMPLEMENTATION_SUMMARY.md`|, foi implementado um sistema de design responsivo completo, garantindo a usabilidade em dispositivos \textit{mobile} e \textit{desktop}.
    \item \textbf{Modo Espectador:} Funcionalidade que permite a usuários assistirem partidas em andamento em tempo real via WebSocket, sem permissão de interação no tabuleiro.
\end{itemize}

As Figuras \ref{fig:tela-lobby} e \ref{fig:tela-jogo} mostram \textit{screenshots} da aplicação final.

\begin{figure}[!htbp]
\centering
\includegraphics[width=1.0\columnwidth]{figs/lobby.png}
\caption{Interface do lobby de jogos, mostrando a seleção de modo de jogo e a lista de jogadores online.}
\label{fig:tela-lobby}
\end{figure}

\begin{figure}[!htbp]
\centering
\includegraphics[width=0.8\columnwidth]{figs/brasao_UFSC_vertical_sigla.pdf}
\caption{Interface da partida (Imagem ilustrativa com Brasão UFSC).}
\label{fig:tela-jogo}
\end{figure}


\subsection{Problemas Encontrados e Soluções}
Durante o desenvolvimento, diversos desafios técnicos surgiram:

\begin{itemize}
    \item \textbf{Instabilidade de Conexão WebSocket:} O \textit{lobby} desconectava imediatamente após a conexão. A causa raiz era que o \textit{backend} aceitava a nova conexão \textit{antes} de fechar a conexão antiga do mesmo usuário. A correção envolveu reordenar o fluxo para: 1) Autenticar token, 2) Fechar conexão antiga, 3) Aceitar nova conexão.
    \item \textbf{Matchmaking com Reconexão:} Jogadores desapareciam da fila ao reconectar. A função \verb|`disconnect_from_lobby()`| removia o usuário de \verb|`online_players`|. A solução foi modificar a lógica para, durante uma reconexão, apenas remover o \textit{socket} antigo, mantendo o usuário na lista de jogadores online.
    \item \textbf{Modal de Vitória Exibido como Erro:} Um bug visual fazia com que a tela de vitória fosse renderizada como um modal de erro. A correção foi feita no `Game.tsx`, garantindo que o estado `isGameOver` com um vencedor disparasse o componente `GameSuccessModal` ao invés de um modal de erro genérico.
    \item \textbf{Dessincronização de Protocolo de Chat:} O Frontend esperava um objeto aninhado e um tipo específico (`chat\_message`), enquanto o Backend enviava um objeto plano com tipo genérico (`chat`). A solução foi a padronização das interfaces de mensagem entre cliente e servidor.
    \item \textbf{Consistência de Estado no Lobby:} Jogos abandonados permaneciam listados. A solução foi implementar um \textit{garbage collector} acionado por eventos de desconexão do WebSocket que verifica salas vazias e atualiza o status no MongoDB atomicamente.
\end{itemize}


\subsection{Vulnerabilidades e Soluções de Segurança}
A segurança foi um pilar do projeto, conforme os requisitos da disciplina:
\begin{itemize}
    \item \textbf{Autenticação:} Implementada com JSON Web Tokens (JWT), utilizando \textit{tokens} de acesso (curta duração) e \textit{refresh tokens} (longa duração) armazenados de forma segura.
    \item \textbf{HTTPS:} O \textit{deploy} no VPS utiliza Nginx como \textit{proxy} reverso com certificados SSL/TLS, garantindo a criptografia.
    \item \textbf{CORS:} O \textit{backend} FastAPI é configurado para permitir requisições apenas das origens do \textit{frontend} definidas em variáveis de ambiente.
    \item \textbf{Prevenção de Injeção:} O uso de um \textit{driver} Motor para o MongoDB mitiga riscos de NoSQL Injection, pois as consultas são parametrizadas. A validação de entrada é feita pelo Pydantic.
    \item \textbf{XSS/CSRF:} Medidas de sanitização de \textit{inputs} no \textit{frontend} (especialmente em campos de chat) e \textit{headers} de segurança (via Nginx/Helmet.js) foram planejadas para prevenir XSS e CSRF.
\end{itemize}


%%------------------------------------------------------
%% Section
\section{Conclusão}
\label{sec:conclusao}
O desenvolvimento do projeto Gomoku Web atingiu seus objetivos principais, entregando uma aplicação \textit{full-stack} robusta que cumpre os requisitos básicos do jogo, mas também implementa um conjunto de funcionalidades avançadas e complexas. A arquitetura escolhida, baseada em FastAPI para o \textit{backend} e React para o \textit{frontend}, provou ser altamente eficaz. O FastAPI gerenciou com excelência as operações assíncronas de WebSockets e as requisições da API, enquanto o React forneceu uma interface de usuário fluida e responsiva. A integração de FFMPEG e um sistema de ranking ELO demonstrou a capacidade de estender a aplicação com serviços ao nível requisitado. Os desafios encontrados, especialmente na estabilidade da comunicação em tempo real e no \textit{design} responsivo, foram superados e resultaram em um sistema mais resiliente e polido.

\begin{thebibliography}{10} 

% requisitos do projeto
\bibitem{projeto_ufsc}
W. B. da Silva, "Instruções para o PW" \emph{Moodle UFSC - INE5646}, 2025. Acessado em: 05/11/2025. [Disponível em: Gomoku/docs/projeto.md]

% arquivos de referencia do texto
\bibitem{func_impl}
A. O. Coelho e L. R. da S. Costa, "FUNCIONALIDADES IMPLEMENTADAS - Gomoku Project," \emph{Documentação do Projeto}, 2025. [Disponível em: \verb|Gomoku/FUNCIONALIDADES_IMPLEMENTADAS.md|]

\bibitem{readme}
A. O. Coelho e L. R. da S. Costa, "Gomoku - Projeto Web UFSC," \emph{Documentação do Projeto (README.md)}, 2025. [Disponível em: Gomoku/README.md]

\bibitem{reqs}
A. O. Coelho e L. R. da S. Costa, "requirements.txt," \emph{Dependências do Backend}, 2025. [Disponível em: Gomoku/backend/requirements.txt]


% documentacao oficial
\bibitem{doc:fastapi}
\emph{FastAPI}, Tiangolo. [Online]. Disponível: \url{https://fastapi.tiangolo.com/}

\bibitem{doc:react}
\emph{React}, Meta. [Online]. Disponível: \url{https://react.dev/}

\bibitem{doc:typescript}
\emph{TypeScript}, Microsoft. [Online]. Disponível: \url{https://www.typescriptlang.org/}

\bibitem{doc:mongodb}
\emph{MongoDB Documentation}, MongoDB Inc. [Online]. Disponível: \url{https://www.mongodb.com/docs/}

\bibitem{doc:ffmpeg}
\emph{FFMPEG}, FFMPEG.org. [Online]. Disponível: \url{https://ffmpeg.org/}


\end{thebibliography}

\appendices

\section{Código Fonte de Configuração}
Principais arquivos de configuração do projeto, que definem a infraestrutura com Docker, as dependências do \textit{backend} e \textit{frontend}.
\subsection{docker-compose.yml}
\subsection{package.json (Frontend)}

\end{document}